# 2.Syntax（语法基础）

* Expression（表达式）
  * Variable（变量）
    * Variable And Constants Declaration（变量与常量声明）
    * Variable Hoisting（变量提升）
  * Assignment（变量赋值）
    * Pass-by-Value & Pass-by-Reference（传值与传引用）    
    * Continuous Assignment（连续赋值）
    * Destructuring Assignment（解构赋值）
    * Copy Composite DataTypes（复合类型拷贝）
* Operator（运算符）
    * Basic（基本运算符）
    * Bit Operator（位运算符）
    * Operator Overloading（运算符重载）
* Scope & Closure（作用域与闭包）
* Lazy Evaluation（惰性求值）
## 
# 表达式（Expression）

## 变量（Variable）

### 变量与常量声明（Variable And Constants Declaration）

#### 变量声明（Variable Declaration）

**1.基础变量**

PHP 中的变量用一个美元符号后面跟变量名来表示。变量名是区分大小写的。变量名与 PHP 中其它的标签一样遵循相同的规则。一个有效的变量名由字母或者下划线开头，后面跟上任意数量的字母，数字，或者下划线。按照正常的正则表达式，它将被表述为：`[a-zA-Z\x7f-\xff][a-zA-Z0-9\x7f-\xff]*` 。

**Example**
```php
<?php

$username = "Leon Kennedy";         // 通过
$_username = "Leon Kennedy";        // 通过
$username1 = "a1";                  // 通过
$user.name = "Leon Kennedy";        // 报错
$用户名称 = "初七";                   // 通过
$UserName = "Leon Kennedy";         // 通过
$userName = "Leon";                 // 通过
$user_name = "Cissy";               // 通过
$1 = 100;                           // 报错
$_100 = 100;                        // 通过
```

**2.****预定义变量**<br />**<br />PHP 提供了大量的预定义变量。由于许多变量依赖于运行的服务器的版本和设置，及其它因素，所以并没有详细的说明文档。一些预定义变量在 PHP 以命令行形式运行时并不生效。PHP 中的许多预定义变量都是“超全局”，这意味它们在一个脚本的全部作用域中都可用。<br /><br />
* $GLOBALS：获取全局变量
* $_SERVER：获取服务器相关信息
* $_GET：获取 HTTP GET 请求数据
* $_POST：获取 HTTP POST 请求数据
* $_FILES：获取 HTTP 上传文件请求数据
* $_COOKIE：获取 COOKIE 数据
* $_SESSION：获取 SESSION 数据
* $_REQUEST：获取 HTTP 请求数据
* $_ENV：获取环境变量
* $php_errormsg：前一个错误信息
* $HTTP_RAW_POST_DATA：原生POST数据
* $http_response_header：HTTP 响应头
* $argc：传递给脚本的参数数目
* $argv：传递给脚本的参数数组

**Example**
```php
<?php

foreach($_SERVER as $key => $value){
	echo "{$key} => {$value}\n";
}
```

    [
      
    ]()
  
    [
      
    ]()
  <br />**3.变量范围**<br />**<br />变量的范围即它定义的上下文背景（也就是它的生效范围）。大部分的 PHP 变量只有一个单独的范围。可以使用 global 关键字声明全局变量。
```php
<?php

$a = 1;
$b = 2;

function sum()
{
	global $a, $b;
	$b = $a + $b;
}

sum();
echo $b;
?>

<?php

function sum_again()
{
	// $_GLOBALS 是一个关联数组，每一个变量为一个元素，键名对应变量名，值对应变量的内容
	$GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];
}

sum();
echo $b;

?>
```

也可以使用 static 关键字在声明静态变量。
```php
<?php

function test(){
  static $a = 0;
  echo $a;
  $a++;
}

test();
test();
test();
test();     // 输出结果为：0123
```

**4.可变变量**<br />**<br />有时候使用可变变量名是很方便的。就是说，一个变量的变量名可以动态的设置和使用。
```php
<?php

$Bar = "a";
$Foo = "Bar";
$World = "Foo";
$Hello = "World";
$a = "Hello";

echo $a."\n";         // Hello
echo $$a."\n";        // World
echo $$$a."\n";       // Foo
echo $$$$a."\n";      // Bar
echo $$$$$a."\n";     // a
echo $$$$$$a."\n";    // Hello
echo $$$$$$$a."\n";   // World
```

**5.来自 PHP 之外的变量**

* HTML 表单（GET 和 POST）
  * 通过预定义变量 `$_GET` 和 `$_POST` 获取。
  * 变量名中的点和空格被转换成下划线。例如 `<input name="a.b" />` 变成了 `$_REQUEST["a_b"]`。
* HTTP 表单（Form）提交数据的方式
    * `enctype="application/x-www-form-urlencoded"` （默认值）
    * `enctype="multipart/form-data"` 
    * 只有当 POST 方法配合 `enctype=multipart/form-data` 时才能正确传输文件。
    * 使用 PUT、PATCH 方法时，需要使用 `enctype="x-www-form-urlencoded"` 。
* HTTP Cookies
  * 如果要将多个值赋给一个 cookie 变量，必须将其赋成数组。

#### 常量声明（Constants Declaration）

**1.语法**<br />**<br />可以用 `define()` 函数来定义常量，在 PHP 5.3.0 以后，可以使用 `const`关键字在类定义之外定义常量。一个常量一旦被定义，就不能再改变或者取消定义。

```php
<?php

define("SEBASTIAN", "Sebastian");
const KENNEDY = "Kennedy";
echo SEBASTIAN.' '.KENNEDY."\n";

const ARR = ['sebastian', 'kennedy'];
var_dump(ARR);
```

**2.预定义常量（魔术常量）**<br />**
* `__LINE__`：文件中的当前行号。
* `__FILE__`：文件的完整路径和文件名。
* `__DIR__`：文件所在的目录。
* `__FUNCTION__`：返回函数被定义时的名字（区分大小写）。
* `__CLASS__`：返回该类被定义时的名字（区分大小写）。
* `__TRAIT__`：返回 trait 被定义时的名字（区分大小写）。
* `__METHOD__`：返回该方法被定义时的名字（区分大小写）。
* `__NAMESPACE__`：当前命名空间的名称（区分大小写）。

```php
<?php

namespace SebastianKennedy\Code;

$line = __LINE__."\n";
$filePath = __FILE__."\n";
$dirPath = __DIR__."\n";

function testFunc(){
    return __FUNCTION__."\n";
}

echo $line;
echo $filePath;
echo $dirPath;
echo testFunc();

trait TestTrait
{
    public function testTrait(){
        return __TRAIT__."\n";
    }
}

class TestClass
{
    use TestTrait;

    public function __construct(){
        return __CLASS__."\n";
    }

    public function testMethod(){
        return __METHOD__."\n";
    }

    public function testNameSpace(){
        return __NAMESPACE__."\n";
    }
}

$class = new TestClass;
echo $class->testMethod();
echo $class->testTrait();
echo $class->testNameSpace();
```

### 变量提升（Variable Hoisting）

因为 PHP 区别全局作用域、函数作用域和块级作用域，PHP 不存在变量提升这个特性。
```php
<?php

$param = 10;

function test($param){
	echo $param;
	$param = "Luis Edware";
}

test($param);
```


## 变量赋值（Assignment）

### 传值与传引用（Pass by Value & Pass by Reference）

PHP 支持四种标量值（标量值不能拆分为更小的单元）：整型值（integer）、浮点数值（float）、字符串值（string）和布尔值（boolean）。PHP 也支持两种复合类型：数组（Array）和对象（Object）。PHP 还支持两种特殊类型：资源（resource）和空（null）。<br /><br /><br />PHP 变量默认总是传值赋值。那也就是说，当将一个表达式的值赋予一个变量时，整个原始表达式的值被赋值到目标变量。这意味着，例如，当一个变量的值赋予另外一个变量时，改变其中一个变量的值，将不会影响到另外一个变量。PHP 也提供了另外一种方式给变量赋值：引用赋值。这意味着新的变量简单的引用了原始变量。改动新的变量将影响到原始变量，反之亦然。PHP 的引用就是同一个变量的别名。<br /><br />
```php
<?php

$foo = 'Bob';
$bar = &$foo;
$bar = "My name is $bar";
echo $bar,$foo;

// 非法的引用赋值；引用没有名字的表达式
$bar = &(24 * 7);

// 非法的引用赋值；只有已经命名的变量才可以引用赋值
function test()
{
	return 25;
}
$bar = &test();
```

PHP 引用相关文章：
* [foreach 循环后留下数组的引用](http://mp.weixin.qq.com/s/U4bpGtQ6goT9XrkwlSMj_g)
* [PHP 引用是个坑，请慎用](https://laravel-china.org/topics/9184/php-reference-is-a-pit-please-use-it-carefully)


### 连续赋值（Continuous Assignment）

```php
<?php

$a = $b = $c = 200;
var_dump($a);
var_dump($b);
var_dump($c);

$foo = $bar = $baz = "Sebastian Kennedy\n";
echo $foo, $bar, $baz;

$arr1 = $arr2 = $arr3 = ['github','coding','gitlab'];
var_dump($arr1);
var_dump($arr2);
var_dump($arr3);

// 可以通过 () 来改变运算符的优先级
$a = ($b = 4) + 5;
echo $a."\n";

// 组合赋值
$a .= $b .= "foo";
echo $a."\n";

// 不用第三个变量，交换两个变量的值
$a = 666;
$b = 233;
$a ^= $b ^= $a ^= $b;
echo $a." - ",$b."\n";

// 不用第三个变量，交换两个变量的值
$a = 222;
$b = 333;
list($a, $b) = [$b, $a];
echo $a." - ",$b."\n";
```

### 解构赋值（Destructuring Assignment）

```php
<?php

$string = "七月十五九月初七,十二月初一九月二十九";
$arr = [
    ["id" => 1, "name" => 'Sebastian'],
    ["id" => 2, "name" => 'Kennedy'],
];

// list() style
list($foo, $bar) = explode(',', $string);
echo $foo." - ".$bar."\n";

list("id" => $id1, "name" => $name1) = $arr[0];
echo $id1." => ". $name1."\n";

// [] style
[$a, $b] = explode(',', $string);
echo $a." - ". $b."\n";

["id" => $id2, "name" => $name2] = $arr[1];
echo $id2." => ", $name2."\n";
```

### 复合类型拷贝（Copy Composite DataTypes）

对象复制可以通过 clone 关键字来完成，对象中的 `__clone()`方法不能被直接调用。当对象被复制后，PHP 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。<br /><br /><br />注意: 引用和拷贝的区别是：拷贝是将原来的变量内容复制下来，拷贝后的变量与原来的变量使用各自的内存，互不干扰。 引用相当于是变量的别名，其实就是用不同的名字访问同一个变量内容。当改变其中一个变量的值时，另一个也跟着发生变化。<br /><br /><br />对于 PHP 对象来说，简单的赋值并不能实现克隆，因为对象是通过伪引用传递的。
```php
<?php

class Example{

    private $a = 1;

    public function plus() {
    		$this->a++;
    }

    public function foo() {
				echo "a={$this->a}\n";
    }
}

$obj = new Example;
$obj->foo();    // 输出 a=1

$obj2 = $obj;
$obj2->plus();
$obj2->foo();   // 输出 a=2

$obj->foo();    // 输出 a=2
```

PHP 提供了 clone 关键字来实现对象的克隆，如下：
```php
<?php

class Example{

    private $a = 1;

    public function plus() {
    		$this->a ++;
    }

    public function foo() {
				echo "a={$this->a}\n";
    }
}

$obj = new Example();
$obj2 = clone $obj;

$obj->foo();    // 输出 a=1

$obj2->plus();
$obj2->foo();   // 输出 a=2

$obj->foo();    // 输出 a=1
```

当复制完成时, 如果定义了 `__clone() 方法`， 则新创建的对象中的 `__clone()` 方法会被调用， 可用于修改属性的值，如下：
```php
<?php

class Example{

    private $a = 1;

    private $instance_no;       // instance 编号

    static public $all = 0;     // instance 总数

    public function foo() {
        echo "a={$this->a}\n";
    }

    public function bar() {
        echo "instance={$this->instance_no}\n";
    }

    public function __construct() {
        // 实例号＋1
        $this->instance_no = ++self::$all;
    }

    public function __clone() {
        // 实例号＋1
        $this->instance_no = ++self::$all;
    }
}

$obj = new Example();
$obj->foo();
$obj->bar();
echo $obj::$all."\n";

$obj2 = clone $obj;
$obj2->foo();
$obj2->bar();
echo $obj2::$all."\n";
```


在 PHP 中，克隆会把对象的所有属性进行克隆，但是如果一个对象中包含引用属性，那么克隆之后，在新生成的对象中这个属性仍然是指向于原来变量的引用，这个成为浅克隆，代码如下：
```php
<?php

class Example{
    private $a = 1;

    public $obj;

    public function plus() {
        $this->a++;
    }

    public function foo() {
        echo "a={$this->a}\n";
    }
}

class Example2{
    public $b = 1;

    public function plus() {
        $this->b ++;
    }

    public function foo() {
        echo "b={$this->b}\n";
    }
}

$obj = new Example;
$obj->obj = new Example2;
$obj2 = clone $obj;

// 修改对象的普通属性
$obj->plus();
$obj->foo();    // 输出 a=2
$obj2->foo();   // 输出 a=1

// 修改对象的引用属性
$obj->obj->plus();
$obj->obj->foo();  // 输出 b=2
$obj2->obj->foo(); // 输出 b=2
```


PHP 如果需要实现深克隆,需要自己实现对引用属性的完全复制，代码如下：
```php
<?php

class Example{

    private $a = 1;

    public $obj;

    public function plus() {
        $this->a ++;
    }

    public function foo() {
        echo "a={$this->a}\n";
    }

    public function __clone(){
        // 当存在对象数组的时候，可以使用以下代码实现深克隆
        foreach($this as $key => $value){
            if (is_object($value) || (is_array($value))) {
                $this->{$key} = unserialize(serialize($value));
            }
        }
    }
}

class Example2{

    public $b = 1;

    public function plus() {
        $this->b ++;
    }

    public function foo() {
        echo "b={$this->b}\n";
    }
}

$obj = new Example;
$obj->obj = new Example2;
$obj2 = clone $obj;

// 修改对象的普通属性
$obj->plus();
$obj->foo();    // 输出 a=2
$obj2->foo();   // 输出 a=1

// 修改对象的引用属性
$obj->obj->plus();
$obj->obj->foo();  // 输出 b=2
$obj2->obj->foo(); // 输出 b=1
```


## 运算符（Operator）

运算符是可以通过给出的一或多个值（用编程行话来说，表达式）来产生另一个值（因而整个结构成为一个表达式）的东西。运算符的种类有：

* 基本运算符（Basic Operators）
  * 算术运算符（Assignment Operator）
  * 比较运算符（Comparison Operator）
  * 错误控制运算符（Error Control Operator）
  * 执行运算符（Execution Operator）
  * 递增/递减运算符（Incrementing / Decrementing Operator）
  * 逻辑运算符（Logical Operator）
  * 字符串运算符（String Operator）
  * 数组运算符（Array operator）
  * 类型运算符（Type Operator）
* 位运算符（Bit Operator）
* 运算符重载（Operator Overloading）

### 基本运算符（Basic Operators）
#### 算术运算符（Assignment Operator）
| 例子 | 名称 | 结果 |
| --- | --- | --- |
| -$a | 取反 | $a 的负值。 |
| $a + $b | 加法 | $a 和 $b 的和。 |
| $a - $b | 减法 | $a 和 $b 的差。 |
| $a * $b | 乘法 | $a 和 $b 的积。 |
| $a / $b | 除法 | $a 除以 $b 的商。 |
| $a % $b | 取模 | $a 除以 $b 的余数。 |
| $a ** $b | 幂 | $a 的 $b 次平方 |

#### 比较运算符（Comparison Operator）
| 例子 | 名称 | 结果 |
| --- | --- | --- |
| $a == $b | 等于 | TRUE，如果类型转换后 $a 等于 $b。 |
| $a === $b | 全等 | TRUE，如果 $a 等于 $b，并且它们的类型也相同。 |
| $a != $b | 不等 | TRUE，如果类型转换后 $a 不等于 $b。 |
| $a <> $b | 不等 | TRUE，如果类型转换后 $a 不等于 $b。 |
| $a !== $b | 不全等 | TRUE，如果 $a 不等于 $b，或者它们的类型不同。 |
| $a < $b | 小与 | TRUE，如果 $a 严格小于 $b。 |
| $a > $b | 大于 | TRUE，如果 $a 严格大于 $b。 |
| $a <= $b | 小于等于 | TRUE，如果 $a 小于或者等于 $b。 |
| $a >= $b | 大于等于 | TRUE，如果 $a 大于或者等于 $b。 |
| $a <=> $b | 结合比较运算符 | 当 $a 小于、等于、大于 $b 时 分别返回一个小于、等于、大于 0 的 integer 值。 PHP 7 开始提供. |
| $a ?? $b ?? $c | NULL 合并操作符 | 从左往右第一个存在且不为 NULL 的操作数。如果都没有定义且不为 NULL，则返回 NULL。PHP 7 开始提供。 |

#### 错误控制运算符（Error Control Operator）
PHP 支持一个错误控制运算符：`@`  。当将其放置在一个 PHP 表达式之前，该表达式可能产生的任何错误信息都被忽略掉。

#### 执行运算符（Execution Operator）
PHP 支持一个执行运算符：反引号（``）。注意这不是单引号！PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出）。使用反引号运算符“`”的效果与函数 shell_exec() 相同。
```php
<?php

$output = `ls -al`;
echo "<pre>$output</pre>";
```


#### 递增/递减运算符（Incrementing / Decrementing Operator）
| 例子 | 名称 | 结果 |
| --- | --- | --- |
| ++$a | 前加 | $a 的值加一，然后返回 $a。 |
| $a++ | 后加 | 返回 $a，然后将 $a 的值加一。 |
| –$a | 前减 | $a 的值减一， 然后返回 $a。 |
| $a– | 后减 | 返回 $a，然后将 $a 的值减一。 |

一个简单的示例脚本
```php
<?php
echo "<h3>Postincrement</h3>";
$a = 5;
echo "Should be 5: " . $a++ . "\n";
echo "Should be 6: " . $a . "\n";
echo "<h3>Preincrement</h3>";
$a = 5;
echo "Should be 6: " . ++$a . "\n";
echo "Should be 6: " . $a . "\n";
echo "<h3>Postdecrement</h3>";
$a = 5;
echo "Should be 5: " . $a-- . "\n";
echo "Should be 4: " . $a . "\n";
echo "<h3>Predecrement</h3>";
$a = 5;
echo "Should be 4: " . --$a . "\n";
echo "Should be 4: " . $a . "\n";
```

#### 逻辑运算符（Logical Operator）
| 例子 | 名称 | 结果 |
| --- | --- | --- |
| $a and $b | And（逻辑与） | TRUE，如果 $a 和 $b 都为 TRUE。 |
| $a or $b | Or（逻辑或） | TRUE，如果 $a 或 $b 任一为 TRUE。 |
| $a xor $b | Xor（逻辑异或） | TRUE，如果 $a 或 $b 任一为 TRUE，但不同时是。 |
| ! $a | Not（逻辑非） | TRUE，如果 $a 不为 TRUE。 |
| $a && $b | And（逻辑与） | TRUE，如果 $a 和 $b 都为 TRUE。 |
| $a ||  $b | Or（逻辑或） | TRUE，如果 $a 或 $b 任一为 TRUE。 |

#### 字符串运算符（String Operator）
有两个字符串（string）运算符。第一个是连接运算符（“.”），它返回其左右参数连接后的字符串。<br />
第二个是连接赋值运算符（“.=”），它将右边参数附加到左边的参数之后。代码如下：
```php
<?php

$a = "Hello ";
$b = $a . "World!"; // now $b contains "Hello World!"

$a = "Hello ";
$a .= "World!";     // now $a contains "Hello World!"
```
###### 
#### 数组运算符（Array Operator）
| 例子 | 名称 | 结果 |
| --- | --- | --- |
| $a + $b | 联合 | $a 和 $b 的联合。 |
| $a == $b | 相等 | 如果 $a 和 $b 具有相同的键／值对则为 TRUE。 |
| $a === $b | 全等 | 如果 $a 和 $b 具有相同的键／值对并且顺序和类型都相同则为 TRUE。 |
| $a != $b | 不等 | 如果 $a 不等于 $b 则为 TRUE。 |
| $a <> $b | 不等 | 如果 $a 不等于 $b 则为 TRUE。 |
| $a !== $b | 不全等 | 如果 $a 不全等于 $b 则为 TRUE。 |

#### 对象类型运算符（Object Type Operator）

instanceof 用于确定一个 PHP 变量是否属于某一类 class 的实例，常见的场景是异常错误捕获

```php
<?php

class ParentClass
{
}

class MyClass extends ParentClass
{
}

$a = new MyClass;
var_dump($a instanceof MyClass);
var_dump($a instanceof ParentClass);
```

### 位运算符

| 例子 | 名称 | 结果 |
| --- | --- | --- |
| $a & $b | And（按位与） | 将把 $a 和 $b 中都为 1 的位设为 1。 |
| $a  $b | Or（按位或） | 将把 $a 和 $b 中任何一个为 1 的位设为 1。 |
| $a ^ $b | Xor（按位异或） | 将把 $a 和 $b 中一个为 1 另一个为 0 的位设为 1。 |
| ~ $a | Not（按位取反） | 将 $a 中为 0 的位设为 1，反之亦然。 |
| $a << $b | Shift left（左移） | 将 $a 中的位向左移动 $b 次（每一次移动都表示“乘以 2”）。 |
| $a >> $b | Shift right（右移） | 将 $a 中的位向右移动 $b 次（每一次移动都表示“除以 2”）。 |


### 运算符重载（Operator Overloading）- [Web 领域几乎没有使用场景]

[PHP 5.6新特性之一：内部操作符重载](https://segmentfault.com/a/1190000000432002)

在计算机程序设计中，运算符重载是多态的一种。这里，运算符被当作多态函数，他们的行为随着其参数类型的不同而不同。简而言之，运算符重载使程序员能够根据运算子类型的不同来决定运算符功能的不同。PHP 支持运算符重载。PHP 5.6 之后，GMP 支持运算符重载，并且造型成数值类型，这使得使用 GMP 的代码更加直观。
```php
<?php

$a = gmp_init(42);
$b = gmp_init(17);

// 意思就是 $a + $b 的 + 的作用等同于 gmp_add() 函数，让代码更加直观。
if (version_compare(PHP_VERSION, '5.6', '<')) {
    echo gmp_intval(gmp_add($a, $b)), PHP_EOL;
    echo gmp_intval(gmp_add($a, 17)), PHP_EOL;
    echo gmp_intval(gmp_add(42, $b)), PHP_EOL;
} else {
    echo $a + $b, PHP_EOL;
    echo $a + 17, PHP_EOL;
    echo 42 + $b, PHP_EOL;
}
```

### 运算符优先级（Operator Precedence）

```php
递增/递减 > ! > 算术运算符 > 大小比较 > (不)相等比较 > 引用 >
位运算符 ^ > 位运算符 | > 逻辑与 > 逻辑或 > 三目 > 赋值 > and > xor > or
```

* 算术运算符（Assignment Operator）
* 比较运算符（Comparison Operator）
* 错误控制运算符（Error Control Operator）
* 执行运算符（Execution Operator）
* 递增/递减运算符（Incrementing / Decrementing Operator）
* 逻辑运算符（Logical Operator）
* 字符串运算符（String Operator）
* 数组运算符（Array operator）
* 类型运算符（Type Operator）

## 匿名函数与闭包（Anonymous functions & Closure）

闭包和匿名函数在 PHP 5.3 中被引入。闭包是指在创建时封装函数周围状态的函数，即使闭包所在的环境不存在了，闭包封装的状态依然存在。匿名函数其实就是没有名称的函数，匿名函数可以赋值给变量，还能像其他任何 PHP 对象那样传递。最经常用作回调函数参数的值。匿名函数和闭包目前是通过 Closure 类来实现的。

**Example:**
```php
<?php

$closure = function($name){
    return sprintf('hello %s', $name);
};

echo $closure("Sebastian Kennedy");
```

之所以能够调用 `$closure` 变量，是因为这个变量的值是一个闭包对象，而且闭包对象实现了 `__invoke()` 魔术方法。只要变量名后有 ()，PHP 就会查找并调用 `__invoke()` 方法：
```php
<?php

class testClosureClass
{
    public function __invoke()
    {
        echo "Hello World";
    }
}

$closure = new testClosureClass;
$closure();     // 输出 Hello World
```

PHP 闭包一般当做函数或方法的回调来使用，如下：
```php
<?php

$numbersPlusOne = array_map(function ($number) {
    return $number + 1;
}, [1, 2, 3]);

var_export($numbersPlusOne);
```


PHP 闭包不会像 JavaScript 闭包那样自动封装应用的状态。在 PHP 中，必须手动调用闭包对象的 `bindTo()` 方法或者使用 `use` 关键字，把状态附加到 PHP 闭包上。以下是使用 `use` 关键字附加闭包的状态：
```php
<?php

function enclosePerson($name)
{
    return function ($doCommand) use ($name) {
        return sprintf('%s, %s', $name, $doCommand);
    };
}

//把字符串 "Clay" 封装在闭包中
$clay = enclosePerson('Clay');

//传入参数，调用闭包
echo $clay('get me sweat tea!'); // Clay, get me sweat tea!
```

我们可以通过 `bindTo()` 方法的第一个参数把 `Closure` 对象的内部状态绑定到其他对象上。可以通过 `bindTo() `方法的第二个参数指定绑定闭包的那个对象所属的 PHP 类。以下是使用 `bindTo()` 方法附加闭包的状态：
```php
<?php

class App
{
  protected $routes = [];
  protected $responseStatus = '200 OK';
  protected $responseContentType = 'text/html';
  protected $responseBody = 'Hello world';

  public function addRoute($routePath, $routeCallback)
  {
    $this->routes[$routePath] = $routeCallback->bindTo($this, __CLASS__);
  }

  public function dispatch($currentPath)
  {
    foreach($this->routes as $routePath => $callback) {
      if ($routePath === $currentPath) {
         $callback();
      }
    }
    header('HTTP/1.1' . $this->responseStatus);
    header('Content-type: ' . $this->responseContentType);
    header('Content-length: ' . mb_strlen($this->responseBody));
    echo $this->responseBody;
  }
}

$app = new App();

$app->addRoute('/users/1', function () {
  $this->responseContentType = 'application/json;charset=utf8';
  $this->responseBody = '{"name" : "Luis Edware", "phone" : "14089950522"}';
});

$app->dispatch('/users/1');
```

## 惰性求值（Lazy Evaluation）

```php
<?php

class Shooting
{
	public function __construct(){
		echo "Biu! Biu! Biu! Da! Da! Da!\n";
	}
}

class Scar
{
	private $closure;
	private $instance;

	public function __construct(Closure $closure){
		$this->closure = $closure;
		$this->instance = $closure->bindTo($this, __CLASS__);
	}

	public function shoot(){
		$closure = $this->closure;
		return $closure();
	}
	
	public function shootAgain(){
		$closure = $this->instance;
		return  $closure();
	}
}

$scar = new Scar(function(){
	return new Shooting;
});

// 不触发射方法就不会 Biu Biu Biu!
$scar->shoot();
$scar->shootAgain();
```

