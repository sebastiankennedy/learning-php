# 2.Syntax（语法基础）

* Expression（表达式）
  * Variable（变量）
    * Variable And Constants Declaration（变量与常量声明）
    * Variable Hoisting（变量提升）
  * Assignment（变量赋值）
    * Pass-by-Value & Pass-by-Reference（传值与传引用）    
    * Continuous Assignment（连续赋值）
    * Destructuring Assignment（解构赋值）
    * Copy Composite DataTypes（复合类型拷贝）
* Operator（运算符）
    * Basic（基本运算符）
    * Bit Operator（位运算符）
    * Operator Overloading（运算符重载）
* Scope & Closure（作用域与闭包）
* Lazy Evaluation（惰性求值）
## 
# 表达式（Expression）

## 变量

### 变量与常量声明（Variable And Constants Declaration）

#### 变量声明（Variable Declaration）

**1.基础变量**

PHP 中的变量用一个美元符号后面跟变量名来表示。变量名是区分大小写的。变量名与 PHP 中其它的标签一样遵循相同的规则。一个有效的变量名由字母或者下划线开头，后面跟上任意数量的字母，数字，或者下划线。按照正常的正则表达式，它将被表述为：`[a-zA-Z\x7f-\xff][a-zA-Z0-9\x7f-\xff]*` 。

**Example**
```php
<?php

$username = "Leon Kennedy";         // 通过
$_username = "Leon Kennedy";        // 通过
$username1 = "a1";                  // 通过
$user.name = "Leon Kennedy";        // 报错
$用户名称 = "初七";                   // 通过
$UserName = "Leon Kennedy";         // 通过
$userName = "Leon";                 // 通过
$user_name = "Cissy";               // 通过
$1 = 100;                           // 报错
$_100 = 100;                        // 通过
```

**2.****预定义变量**<br />**<br />PHP 提供了大量的预定义变量。由于许多变量依赖于运行的服务器的版本和设置，及其它因素，所以并没有详细的说明文档。一些预定义变量在 PHP 以命令行形式运行时并不生效。PHP 中的许多预定义变量都是“超全局”，这意味它们在一个脚本的全部作用域中都可用。<br /><br />
* $GLOBALS：获取全局变量
* $_SERVER：获取服务器相关信息
* $_GET：获取 HTTP GET 请求数据
* $_POST：获取 HTTP POST 请求数据
* $_FILES：获取 HTTP 上传文件请求数据
* $_COOKIE：获取 COOKIE 数据
* $_SESSION：获取 SESSION 数据
* $_REQUEST：获取 HTTP 请求数据
* $_ENV：获取环境变量
* $php_errormsg：前一个错误信息
* $HTTP_RAW_POST_DATA：原生POST数据
* $http_response_header：HTTP 响应头
* $argc：传递给脚本的参数数目
* $argv：传递给脚本的参数数组

**Example**
```php
<?php

foreach($_SERVER as $key => $value){
	echo "{$key} => {$value}\n";
}
```

    [
      
    ]()
  
    [
      
    ]()
  <br />**3.变量范围**<br />**<br />变量的范围即它定义的上下文背景（也就是它的生效范围）。大部分的 PHP 变量只有一个单独的范围。可以使用 global 关键字声明全局变量。
```php
<?php

$a = 1;
$b = 2;

function sum()
{
	global $a, $b;
	$b = $a + $b;
}

sum();
echo $b;
?>

<?php

function sum_again()
{
	// $_GLOBALS 是一个关联数组，每一个变量为一个元素，键名对应变量名，值对应变量的内容
	$GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];
}

sum();
echo $b;

?>
```

也可以使用 static 关键字在声明静态变量。
```php
<?php

function test(){
  static $a = 0;
  echo $a;
  $a++;
}

test();
test();
test();
test();     // 输出结果为：0123
```

**4.可变变量**<br />**<br />有时候使用可变变量名是很方便的。就是说，一个变量的变量名可以动态的设置和使用。
```php
<?php

$Bar = "a";
$Foo = "Bar";
$World = "Foo";
$Hello = "World";
$a = "Hello";

echo $a."\n";         // Hello
echo $$a."\n";        // World
echo $$$a."\n";       // Foo
echo $$$$a."\n";      // Bar
echo $$$$$a."\n";     // a
echo $$$$$$a."\n";    // Hello
echo $$$$$$$a."\n";   // World
```

**5.来自 PHP 之外的变量**

* HTML 表单（GET 和 POST）
  * 通过预定义变量 `$_GET` 和 `$_POST` 获取。
  * 变量名中的点和空格被转换成下划线。例如 `<input name="a.b" />` 变成了 `$_REQUEST["a_b"]`。
* HTTP 表单（Form）提交数据的方式
    * `enctype="application/x-www-form-urlencoded"` （默认值）
    * `enctype="multipart/form-data"` 
    * 只有当 POST 方法配合 `enctype=multipart/form-data` 时才能正确传输文件。
    * 使用 PUT、PATCH 方法时，需要使用 `enctype="x-www-form-urlencoded"` 。
* HTTP Cookies
  * 如果要将多个值赋给一个 cookie 变量，必须将其赋成数组。

#### 常量声明（Constants Declaration）

**1.语法**<br />**<br />可以用 `define()` 函数来定义常量，在 PHP 5.3.0 以后，可以使用 `const`关键字在类定义之外定义常量。一个常量一旦被定义，就不能再改变或者取消定义。

```php
<?php

define("SEBASTIAN", "Sebastian");
const KENNEDY = "Kennedy";
echo SEBASTIAN.' '.KENNEDY."\n";

const ARR = ['sebastian', 'kennedy'];
var_dump(ARR);
```

**2.预定义常量（魔术常量）**<br />**
* `__LINE__`：文件中的当前行号。
* `__FILE__`：文件的完整路径和文件名。
* `__DIR__`：文件所在的目录。
* `__FUNCTION__`：返回函数被定义时的名字（区分大小写）。
* `__CLASS__`：返回该类被定义时的名字（区分大小写）。
* `__TRAIT__`：返回 trait 被定义时的名字（区分大小写）。
* `__METHOD__`：返回该方法被定义时的名字（区分大小写）。
* `__NAMESPACE__`：当前命名空间的名称（区分大小写）。

```php
<?php

namespace SebastianKennedy\Code;

$line = __LINE__."\n";
$filePath = __FILE__."\n";
$dirPath = __DIR__."\n";

function testFunc(){
    return __FUNCTION__."\n";
}

echo $line;
echo $filePath;
echo $dirPath;
echo testFunc();

trait TestTrait
{
    public function testTrait(){
        return __TRAIT__."\n";
    }
}

class TestClass
{
    use TestTrait;

    public function __construct(){
        return __CLASS__."\n";
    }

    public function testMethod(){
        return __METHOD__."\n";
    }

    public function testNameSpace(){
        return __NAMESPACE__."\n";
    }
}

$class = new TestClass;
echo $class->testMethod();
echo $class->testTrait();
echo $class->testNameSpace();
```

### 变量提升（Variable Hoisting）

因为 PHP 区别全局作用域、函数作用域和块级作用域，PHP 不存在变量提升这个特性。
```php
<?php

$param = 10;

function test($param){
	echo $param;
	$param = "Luis Edware";
}

test($param);
```


## 变量赋值（Assignment）

### 传值与传引用（Pass by Value & Pass by Reference）

PHP 支持四种标量值（标量值不能拆分为更小的单元）：整型值（integer）、浮点数值（float）、字符串值（string）和布尔值（boolean）。PHP 也支持两种复合类型：数组（Array）和对象（Object）。PHP 还支持两种特殊类型：资源（resource）和空（null）。<br /><br /><br />PHP 变量默认总是传值赋值。那也就是说，当将一个表达式的值赋予一个变量时，整个原始表达式的值被赋值到目标变量。这意味着，例如，当一个变量的值赋予另外一个变量时，改变其中一个变量的值，将不会影响到另外一个变量。PHP 也提供了另外一种方式给变量赋值：引用赋值。这意味着新的变量简单的引用了原始变量。改动新的变量将影响到原始变量，反之亦然。PHP 的引用就是同一个变量的别名。<br /><br />
```php
<?php

$foo = 'Bob';
$bar = &$foo;
$bar = "My name is $bar";
echo $bar,$foo;

// 非法的引用赋值；引用没有名字的表达式
$bar = &(24 * 7);

// 非法的引用赋值；只有已经命名的变量才可以引用赋值
function test()
{
	return 25;
}
$bar = &test();
```

PHP 引用相关文章：
* [foreach 循环后留下数组的引用](http://mp.weixin.qq.com/s/U4bpGtQ6goT9XrkwlSMj_g)
* [PHP 引用是个坑，请慎用](https://laravel-china.org/topics/9184/php-reference-is-a-pit-please-use-it-carefully)


### 连续赋值（Continuous Assignment）

```php
<?php

$a = $b = $c = 200;
var_dump($a);
var_dump($b);
var_dump($c);

$foo = $bar = $baz = "Sebastian Kennedy\n";
echo $foo, $bar, $baz;

$arr1 = $arr2 = $arr3 = ['github','coding','gitlab'];
var_dump($arr1);
var_dump($arr2);
var_dump($arr3);

// 可以通过 () 来改变运算符的优先级
$a = ($b = 4) + 5;
echo $a."\n";

// 组合赋值
$a .= $b .= "foo";
echo $a."\n";

// 不用第三个变量，交换两个变量的值
$a = 666;
$b = 233;
$a ^= $b ^= $a ^= $b;
echo $a." - ",$b."\n";

// 不用第三个变量，交换两个变量的值
$a = 222;
$b = 333;
list($a, $b) = [$b, $a];
echo $a." - ",$b."\n";
```

### 解构赋值（Destructuring Assignment）

```php
<?php

$string = "七月十五九月初七,十二月初一九月二十九";
$arr = [
    ["id" => 1, "name" => 'Sebastian'],
    ["id" => 2, "name" => 'Kennedy'],
];

// list() style
list($foo, $bar) = explode(',', $string);
echo $foo." - ".$bar."\n";

list("id" => $id1, "name" => $name1) = $arr[0];
echo $id1." => ". $name1."\n";

// [] style
[$a, $b] = explode(',', $string);
echo $a." - ". $b."\n";

["id" => $id2, "name" => $name2] = $arr[1];
echo $id2." => ", $name2."\n";
```

### 复合类型拷贝（Copy Composite DataTypes）

对象复制可以通过 clone 关键字来完成，对象中的 `__clone()`方法不能被直接调用。当对象被复制后，PHP 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。<br /><br /><br />注意: 引用和拷贝的区别是：拷贝是将原来的变量内容复制下来，拷贝后的变量与原来的变量使用各自的内存，互不干扰。 引用相当于是变量的别名，其实就是用不同的名字访问同一个变量内容。当改变其中一个变量的值时，另一个也跟着发生变化。<br /><br /><br />对于 PHP 对象来说，简单的赋值并不能实现克隆，因为对象是通过伪引用传递的。
```php
<?php

class Example{

    private $a = 1;

    public function plus() {
    		$this->a++;
    }

    public function foo() {
				echo "a={$this->a}\n";
    }
}

$obj = new Example;
$obj->foo();    // 输出 a=1

$obj2 = $obj;
$obj2->plus();
$obj2->foo();   // 输出 a=2

$obj->foo();    // 输出 a=2
```

PHP 提供了 clone 关键字来实现对象的克隆，如下：
```php
<?php

class Example{

    private $a = 1;

    public function plus() {
    		$this->a ++;
    }

    public function foo() {
				echo "a={$this->a}\n";
    }
}

$obj = new Example();
$obj2 = clone $obj;

$obj->foo();    // 输出 a=1

$obj2->plus();
$obj2->foo();   // 输出 a=2

$obj->foo();    // 输出 a=1
```

当复制完成时, 如果定义了 `__clone() 方法`， 则新创建的对象中的 `__clone()` 方法会被调用， 可用于修改属性的值，如下：
```php
<?php

class Example{

    private $a = 1;

    private $instance_no;       // instance 编号

    static public $all = 0;     // instance 总数

    public function foo() {
        echo "a={$this->a}\n";
    }

    public function bar() {
        echo "instance={$this->instance_no}\n";
    }

    public function __construct() {
        // 实例号＋1
        $this->instance_no = ++self::$all;
    }

    public function __clone() {
        // 实例号＋1
        $this->instance_no = ++self::$all;
    }
}

$obj = new Example();
$obj->foo();
$obj->bar();
echo $obj::$all."\n";

$obj2 = clone $obj;
$obj2->foo();
$obj2->bar();
echo $obj2::$all."\n";
```


在 PHP 中，克隆会把对象的所有属性进行克隆，但是如果一个对象中包含引用属性，那么克隆之后，在新生成的对象中这个属性仍然是指向于原来变量的引用，这个成为浅克隆，代码如下：
```php
<?php

class Example{
    private $a = 1;

    public $obj;

    public function plus() {
        $this->a++;
    }

    public function foo() {
        echo "a={$this->a}\n";
    }
}

class Example2{
    public $b = 1;

    public function plus() {
        $this->b ++;
    }

    public function foo() {
        echo "b={$this->b}\n";
    }
}

$obj = new Example;
$obj->obj = new Example2;
$obj2 = clone $obj;

// 修改对象的普通属性
$obj->plus();
$obj->foo();    // 输出 a=2
$obj2->foo();   // 输出 a=1

// 修改对象的引用属性
$obj->obj->plus();
$obj->obj->foo();  // 输出 b=2
$obj2->obj->foo(); // 输出 b=2
```


PHP 如果需要实现深克隆,需要自己实现对引用属性的完全复制，代码如下：
```php
<?php

class Example{

    private $a = 1;

    public $obj;

    public function plus() {
        $this->a ++;
    }

    public function foo() {
        echo "a={$this->a}\n";
    }

    public function __clone(){
        // 当存在对象数组的时候，可以使用以下代码实现深克隆
        foreach($this as $key => $value){
            if (is_object($value) || (is_array($value))) {
                $this->{$key} = unserialize(serialize($value));
            }
        }
    }
}

class Example2{

    public $b = 1;

    public function plus() {
        $this->b ++;
    }

    public function foo() {
        echo "b={$this->b}\n";
    }
}

$obj = new Example;
$obj->obj = new Example2;
$obj2 = clone $obj;

// 修改对象的普通属性
$obj->plus();
$obj->foo();    // 输出 a=2
$obj2->foo();   // 输出 a=1

// 修改对象的引用属性
$obj->obj->plus();
$obj->obj->foo();  // 输出 b=2
$obj2->obj->foo(); // 输出 b=1
```

